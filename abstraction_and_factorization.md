### Факторизация
У нас изначально есть три независимых друг от друга иерархии классов.
 - для обработки ДНК последовательностей, где нужно хранить обрабатываемую строку, проверять, что на вход подана действительно строка генетического кода, совершать некоторые базовые преобразования, вроде выделения фрагментов или замены 'T' на 'U', добавлять нуклеотиды, разрезать строку по определённым словам, и уметь возвращать строку после всех преобразований
 - для обработки некоторого текста на русском или английском языке (Word-подобный формат) - хранение текста в качества одной строки, рендеринг текста, добавление новых слов в конец, выделение фрагметов текста на основе разделителей, подсчёт слов.
 - для создания компилятора для придуманного нами языка программирования - хранение текста программы, компиляция и рендеринг итогового байткода, разделение текста по границам токенов, возможность добавить сслыку на другой файл кода для возможность собирать проект из нескольких.
   
Всё эти случаи вполне можно генерализовать в общий класс "Текст", в котором будет, как минимум, возможноть хранения "сырой" последовательности символов, метод валидации, метод добавления новых символов в конец существующей последовательноти, и команда "отрендерить". Возможно так же добавить поле для хранения разделителей (которые можно создать отдельным классом) или метод поиска по строке.

### Абстрагирование
Самое очевидное - проект начинается как простое приложение типа Anki. 
- Под него создаётся некоторая иерархия классов, подразумевающая очень специальную механику работы с экраном - нужно хранить набор правильных ответов, результат пользовательских тапов, метода для сопоставления одного с другим, и счётчик количества очков. Для отдельных экранов ниже в иерархии добавляется функционал для расположения нескольких ответов на экране, когда надо не просто вспомнить слово, а сопоставить несколько друг с другом, и, например, таймер. 
- Позже, когда приложение захочется сделать больше и интереснее, мы захотим мини-игры, вроде "виселицы", или режим "Исследуй", где нужно просто показать карточку, без проверки правильного ответа, лучше будет из существующей логики выделить базовый класс, где останется то, что нужно, чтобы хранить слова для текущей сессии в виде списков бука, и некоторая рудиментарная логика "открыть слова" - а остальное (игры, исследование, сопоставление ответов с образцом) уедет ниже по иерархии, каждое на свою ветку.
